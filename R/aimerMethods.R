#'predicts new values for an aimer model.
#'
#'@param object required, a model generated by the aimer function.
#'@param newdata required, a new data matrix to predict with.
#'
#'@return predicted value vector of length nrow(newdata).
#'
#'@export
predict.aimer <- function(object, newdata, ...){
    newdata = as.matrix(newdata)
    newdata = scale(newdata, scale = FALSE)
    indeces = object$beta != 0
    newdata[,indeces] %*% object$beta[indeces]
}




#'predicts new values for an aimerCV model.
#'
#'@param object required, a model generated by the aimerCV function.
#'@param newdata required, a new data matrix to predict with.
#'
#'@return predicted value vector of length nrow(newdata).
#'
#'@export
predict.aimerCV <- function(object, newdata, ...){
    predict.aimer(object, newdata)
}



#'returns the fitted values of an aimer model.
#'
#'@param object required, an aimer model.
#'
#'@return fitted values of the original data (vector of length n).
#'
#'@export
fitted.aimer <- function(object, ...){
    object$fitted
}

#'returns the fitted values of an aimerCV model.
#'
#'@param object required, an aimerCV model.
#'
#'@return fitted values of the original data (vector of length n).
#'
#'@export
fitted.aimerCV <- function(object, ...){
    object$fitted
}

#'returns the residuals of an aimer model.
#' 
#'@param object required, an aimer model.
#'
#'@return residuals of the original data (vector of length n).
#'
#'@export
residuals.aimer <- function(object, ...){
    object$residuals
}


#'returns the residuals of an aimerCV model.
#' 
#'@param object required, an aimerCV model.
#'
#'@return residuals of the original data (vector of length n).
#'
#'@export
residuals.aimerCV <- function(object, ...){
    object$residuals
}




#'returns the coefficients of an aimer model.
#'
#'@param object required, an aimer model.
#'
#'@return coefficient vector for the model
#'
#'@export
coefficients.aimer <- function(object, ...){
    object$beta
}



#'returns the coefficients of an aimerCV model.
#'
#'@param object required, an aimerCV model.
#'
#'@return coefficient vector for the model
#'
#'@export
coefficients.aimerCV <- function(object, ...){
    object$beta
}


#'plots the residuals in terms of the fitted values for an aimer model
#'
#'@param object required, an aimer model.
#'
#'@return void.
#'
#'@export
plot.aimer <- function(object, ...){
    plot(object$residuals ~ object$fitted, xlab = "fitted values", ylab = "residuals")
}

#'creates a heatmap of each value of ncomps tested in an aimerCV model
#'
#'@param object required, an aimerCV model.
#'
#'@return void.
#'
#'@export
plot.aimerCV <- function(object, ...){
    original = par(ask = TRUE)
    MyDF = data.frame(expand.grid(object$ncomps, object$nCovs))
    best = match(object$nCov.select.best, object$nCovs.select)
    getColor <- function(coord){
        object$mse[best, coord[1], coord[2]]
    }
    MyDF$col = apply(expand.grid(1:length(object$ncomps), 1:length(object$nCovs)), MARGIN = 1, FUN = getColor)
    p = ggplot2::ggplot(MyDF, ggplot2::aes_string(x = 'Var1', y = 'Var2', fill = 'col')) +
            ggplot2::geom_tile() +
            ggplot2::scale_fill_continuous(low = 'blue', high = 'red', guide = ggplot2::guide_legend(title = 'MSE')) + 
            ggplot2::xlab("ncomps") + ggplot2::ylab("nCovs") + ggplot2::ggtitle("For Optimal nCov.select")
    print(p)
#    image(x = object$ncomps, y = object$nCovs, 
#          z = object$mse[object$nCovs.select == object$nCov.select.best,,], 
#          xlab = "ncomps", ylab = "ncovs", main = "for optimal value of nCovs.select")
    MyDF = data.frame(expand.grid(object$nCovs.select, object$ncomps))
    best = match(object$nCov.best, object$nCovs)
    getColor <- function(coord){
        object$mse[coord[1], coord[2], best]
    }
    MyDF$col = apply(expand.grid(1:length(object$nCovs.select), 1:length(object$ncomps)), MARGIN = 1, FUN = getColor)
    p = ggplot2::ggplot(MyDF, ggplot2::aes_string(x = 'Var1', y = 'Var2', fill = 'col')) +
        ggplot2::geom_tile() +
        ggplot2::scale_fill_continuous(low = 'blue', high = 'red', guide = ggplot2::guide_legend(title = 'MSE')) + 
        ggplot2::xlab("nCovs.select") + ggplot2::ylab("ncomps") + ggplot2::ggtitle("For Optimal nCovs")
    print(p)
#    image(x = object$nCovs.select, y = object$ncomps, 
#          z = object$mse[,,object$nCovs == object$nCov.best], 
#          xlab = "nCovs.select", ylab = "ncomps", main = "for optimal value of nCovs")
    MyDF = data.frame(expand.grid(object$nCovs.select, object$nCovs))
    best = match(object$ncomp.best, object$ncomps)
    getColor <- function(coord){
        object$mse[coord[1], best, coord[2]]
    }
    MyDF$col = apply(expand.grid(1:length(object$nCovs.select), 1:length(object$nCovs)), MARGIN = 1, FUN = getColor)
    p = ggplot2::ggplot(MyDF, ggplot2::aes_string(x = 'Var1', y = 'Var2', fill = 'col')) +
        ggplot2::geom_tile() +
        ggplot2::scale_fill_continuous(low = 'blue', high = 'red', guide = ggplot2::guide_legend(title = 'MSE')) + 
        ggplot2::xlab("nCovs.select") + ggplot2::ylab("nCovs") + ggplot2::ggtitle("For Optimal ncomps")
    print(p)
#    image(x = object$nCovs.select, y = object$nCovs, 
#          z = object$mse[,object$ncomps == object$ncomp.best,], 
#          xlab = "nCovs.select", ylab = "nCovs", main = "for optimal value of ncomps")
    par(original)
}